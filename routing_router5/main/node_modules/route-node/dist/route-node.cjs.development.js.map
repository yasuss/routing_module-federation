{"version":3,"file":"route-node.cjs.development.js","sources":["../src/helpers.ts","../src/matchChildren.ts","../src/sortChildren.ts","../src/RouteNode.ts"],"sourcesContent":["import { build } from 'search-params'\nimport {\n  BuildOptions,\n  MatchResponse,\n  RouteNode,\n  RouteNodeState,\n  RouteNodeStateMeta\n} from './RouteNode'\n\nexport const getMetaFromSegments = (\n  segments: RouteNode[]\n): RouteNodeStateMeta => {\n  let accName = ''\n\n  return segments.reduce<RouteNodeStateMeta>((meta, segment) => {\n    const urlParams =\n      segment.parser?.urlParams.reduce<Record<string, any>>((params, p) => {\n        params[p] = 'url'\n        return params\n      }, {}) ?? {}\n\n    const allParams =\n      segment.parser?.queryParams.reduce<Record<string, any>>((params, p) => {\n        params[p] = 'query'\n        return params\n      }, urlParams) ?? {}\n\n    if (segment.name !== undefined) {\n      accName = accName ? accName + '.' + segment.name : segment.name\n      meta[accName] = allParams\n    }\n    return meta\n  }, {})\n}\n\nexport const buildStateFromMatch = (\n  match: MatchResponse\n): RouteNodeState | null => {\n  if (!match || !match.segments || !match.segments.length) {\n    return null\n  }\n\n  const name = match.segments\n    .map(segment => segment.name)\n    .filter(name => name)\n    .join('.')\n  const params = match.params\n\n  return {\n    name,\n    params,\n    meta: getMetaFromSegments(match.segments)\n  }\n}\n\nexport const buildPathFromSegments = (\n  segments: RouteNode[],\n  params: Record<string, any> = {},\n  options: BuildOptions = {}\n) => {\n  const { queryParamsMode = 'default', trailingSlashMode = 'default' } = options\n  const searchParams: string[] = []\n  const nonSearchParams: string[] = []\n\n  for (const segment of segments) {\n    const { parser } = segment\n\n    if (parser) {\n      searchParams.push(...parser.queryParams)\n      nonSearchParams.push(...parser.urlParams)\n      nonSearchParams.push(...parser.spatParams)\n    }\n  }\n\n  if (queryParamsMode === 'loose') {\n    const extraParams = Object.keys(params).reduce<string[]>(\n      (acc, p) =>\n        searchParams.indexOf(p) === -1 && nonSearchParams.indexOf(p) === -1\n          ? acc.concat(p)\n          : acc,\n      []\n    )\n    searchParams.push(...extraParams)\n  }\n\n  const searchParamsObject = searchParams.reduce<Record<string, any>>(\n    (acc, paramName) => {\n      if (Object.keys(params).indexOf(paramName) !== -1) {\n        acc[paramName] = params[paramName]\n      }\n\n      return acc\n    },\n    {}\n  )\n\n  const searchPart = build(searchParamsObject, options.queryParams)\n\n  const path = segments\n    .reduce<string>((path, segment) => {\n      const segmentPath =\n        segment.parser?.build(params, {\n          ignoreSearch: true,\n          queryParams: options.queryParams,\n          urlParamsEncoding: options.urlParamsEncoding\n        }) ?? ''\n\n      return segment.absolute ? segmentPath : path + segmentPath\n    }, '')\n    // remove repeated slashes\n    .replace(/\\/\\/{1,}/g, '/')\n\n  let finalPath = path\n\n  if (trailingSlashMode === 'always') {\n    finalPath = /\\/$/.test(path) ? path : `${path}/`\n  } else if (trailingSlashMode === 'never' && path !== '/') {\n    finalPath = /\\/$/.test(path) ? path.slice(0, -1) : path\n  }\n\n  return finalPath + (searchPart ? '?' + searchPart : '')\n}\n\nexport const getPathFromSegments = (segments: RouteNode[]): string | null =>\n  segments ? segments.map(segment => segment.path).join('') : null\n","import { omit, parse } from 'search-params'\nimport { MatchOptions, MatchResponse, RouteNode } from './RouteNode'\nimport { TestMatch } from 'path-parser'\n\nconst getPath = (path: string): string => path.split('?')[0]\n\nconst getSearch = (path: string): string => path.split('?')[1] || ''\n\nconst matchChildren = (\n  nodes: RouteNode[],\n  pathSegment: string,\n  currentMatch: MatchResponse,\n  options: MatchOptions = {},\n  consumedBefore?: string\n): MatchResponse | null => {\n  const {\n    queryParamsMode = 'default',\n    strictTrailingSlash = false,\n    strongMatching = true,\n    caseSensitive = false\n  } = options\n  const isRoot = nodes.length === 1 && nodes[0].name === ''\n  // for (child of node.children) {\n  for (const child of nodes) {\n    // Partially match path\n    let match: TestMatch | null = null\n    let remainingPath\n    let segment = pathSegment\n\n    if (consumedBefore === '/' && child.path === '/') {\n      // when we encounter repeating slashes we add the slash\n      // back to the URL to make it de facto pathless\n      segment = '/' + pathSegment\n    }\n\n    if (!child.children.length) {\n      match = child.parser!.test(segment, {\n        caseSensitive,\n        strictTrailingSlash,\n        queryParams: options.queryParams,\n        urlParamsEncoding: options.urlParamsEncoding\n      })\n    }\n\n    if (!match) {\n      match = child.parser!.partialTest(segment, {\n        delimited: strongMatching,\n        caseSensitive,\n        queryParams: options.queryParams,\n        urlParamsEncoding: options.urlParamsEncoding\n      })\n    }\n\n    if (match) {\n      // Remove consumed segment from path\n      let consumedPath = child.parser!.build(match, {\n        ignoreSearch: true,\n        urlParamsEncoding: options.urlParamsEncoding\n      })\n\n      if (!strictTrailingSlash && !child.children.length) {\n        consumedPath = consumedPath.replace(/\\/$/, '')\n      }\n\n      // Can't create a regexp from the path because it might contain a\n      // regexp character.\n      if (segment.toLowerCase().indexOf(consumedPath.toLowerCase()) === 0) {\n        remainingPath = segment.slice(consumedPath.length)\n      } else {\n        remainingPath = segment\n      }\n\n      if (!strictTrailingSlash && !child.children.length) {\n        remainingPath = remainingPath.replace(/^\\/\\?/, '?')\n      }\n\n      const { querystring } = omit(\n        getSearch(segment.replace(consumedPath, '')),\n        child.parser!.queryParams,\n        options.queryParams\n      )\n      remainingPath =\n        getPath(remainingPath) + (querystring ? `?${querystring}` : '')\n      if (\n        !strictTrailingSlash &&\n        !isRoot &&\n        remainingPath === '/' &&\n        !/\\/$/.test(consumedPath)\n      ) {\n        remainingPath = ''\n      }\n\n      currentMatch.segments.push(child)\n      Object.keys(match).forEach(\n        param => (currentMatch.params[param] = match![param])\n      )\n\n      if (!isRoot && !remainingPath.length) {\n        // fully matched\n        return currentMatch\n      }\n      if (\n        !isRoot &&\n        queryParamsMode !== 'strict' &&\n        remainingPath.indexOf('?') === 0\n      ) {\n        // unmatched queryParams in non strict mode\n        const remainingQueryParams = parse(\n          remainingPath.slice(1),\n          options.queryParams\n        ) as any\n\n        Object.keys(remainingQueryParams).forEach(\n          name => (currentMatch.params[name] = remainingQueryParams[name])\n        )\n        return currentMatch\n      }\n      // Continue matching on non absolute children\n      const children = child.getNonAbsoluteChildren()\n      // If no children to match against but unmatched path left\n      if (!children.length) {\n        return null\n      }\n      // Else: remaining path and children\n      return matchChildren(\n        children,\n        remainingPath,\n        currentMatch,\n        options,\n        consumedPath\n      )\n    }\n  }\n\n  return null\n}\n\nexport default matchChildren\n","import { RouteNode } from './RouteNode'\n\nexport default function sortChildren(children: RouteNode[]) {\n  const originalChildren = children.slice(0)\n\n  return children.sort(sortPredicate(originalChildren))\n}\n\nconst sortPredicate = (originalChildren: RouteNode[]) => (\n  left: RouteNode,\n  right: RouteNode\n): number => {\n  const leftPath = left.path\n    .replace(/<.*?>/g, '')\n    .split('?')[0]\n    .replace(/(.+)\\/$/, '$1')\n  const rightPath = right.path\n    .replace(/<.*?>/g, '')\n    .split('?')[0]\n    .replace(/(.+)\\/$/, '$1')\n\n  // '/' last\n  if (leftPath === '/') {\n    return 1\n  }\n  if (rightPath === '/') {\n    return -1\n  }\n  // Spat params last\n  if (left.parser?.hasSpatParam) {\n    return 1\n  }\n  if (right.parser?.hasSpatParam) {\n    return -1\n  }\n  // No spat, number of segments (less segments last)\n  const leftSegments = (leftPath.match(/\\//g) || []).length\n  const rightSegments = (rightPath.match(/\\//g) || []).length\n  if (leftSegments < rightSegments) {\n    return 1\n  }\n  if (leftSegments > rightSegments) {\n    return -1\n  }\n  // Same number of segments, number of URL params ascending\n  const leftParamsCount = left.parser?.urlParams.length ?? 0\n  const rightParamsCount = right.parser?.urlParams.length ?? 0\n  if (leftParamsCount < rightParamsCount) {\n    return -1\n  }\n  if (leftParamsCount > rightParamsCount) {\n    return 1\n  }\n  // Same number of segments and params, last segment length descending\n  const leftParamLength = (leftPath.split('/').slice(-1)[0] || '').length\n  const rightParamLength = (rightPath.split('/').slice(-1)[0] || '').length\n  if (leftParamLength < rightParamLength) {\n    return 1\n  }\n  if (leftParamLength > rightParamLength) {\n    return -1\n  }\n  // Same last segment length, preserve definition order. Note that we\n  // cannot just return 0, as sort is not guaranteed to be a stable sort.\n  return originalChildren.indexOf(left) - originalChildren.indexOf(right)\n}\n","import { Path, URLParamsEncodingType } from 'path-parser'\nimport { IOptions as QueryParamsOptions } from 'search-params'\n\nimport {\n  buildPathFromSegments,\n  buildStateFromMatch,\n  getMetaFromSegments,\n  getPathFromSegments\n} from './helpers'\nimport matchChildren from './matchChildren'\nimport sortChildren from './sortChildren'\n\nexport interface RouteDefinition {\n  name: string\n  path: string\n  [key: string]: any\n}\nexport type Route = RouteNode | RouteDefinition\nexport type Callback = (...args: any[]) => void\nexport type TrailingSlashMode = 'default' | 'never' | 'always'\nexport type QueryParamsMode = 'default' | 'strict' | 'loose'\n\nexport interface BuildOptions {\n  trailingSlashMode?: TrailingSlashMode\n  queryParamsMode?: QueryParamsMode\n  queryParams?: QueryParamsOptions\n  urlParamsEncoding?: URLParamsEncodingType\n}\n\nexport interface MatchOptions {\n  caseSensitive?: boolean\n  trailingSlashMode?: TrailingSlashMode\n  queryParamsMode?: QueryParamsMode\n  queryParams?: QueryParamsOptions\n  strictTrailingSlash?: boolean\n  strongMatching?: boolean\n  urlParamsEncoding?: URLParamsEncodingType\n}\n\nexport { QueryParamsOptions }\n\nexport interface MatchResponse {\n  segments: RouteNode[]\n  params: Record<string, any>\n}\n\nexport interface RouteNodeStateMeta {\n  [routeName: string]: {\n    [routeParams: string]: 'query' | 'url'\n  }\n}\n\nexport interface RouteNodeState {\n  name: string\n  params: Record<string, any>\n  meta: RouteNodeStateMeta\n}\n\nexport interface RouteNodeOptions {\n  finalSort?: boolean\n  onAdd?: Callback\n  parent?: RouteNode\n  sort?: boolean\n}\n\nexport class RouteNode {\n  public name: string\n  public absolute: boolean\n  public path: string\n  public parser: Path | null\n  public children: RouteNode[]\n  public parent?: RouteNode\n\n  constructor(\n    name: string = '',\n    path: string = '',\n    childRoutes: Route[] = [],\n    options: RouteNodeOptions = {}\n  ) {\n    this.name = name\n    this.absolute = /^~/.test(path)\n    this.path = this.absolute ? path.slice(1) : path\n\n    this.parser = this.path ? new Path(this.path) : null\n    this.children = []\n    this.parent = options.parent\n\n    this.checkParents()\n\n    this.add(\n      childRoutes,\n      options.onAdd,\n      options.finalSort ? false : options.sort !== false\n    )\n\n    if (options.finalSort) {\n      this.sortDescendants()\n    }\n\n    return this\n  }\n\n  public getParentSegments(segments: RouteNode[] = []): RouteNode[] {\n    return this.parent && this.parent.parser\n      ? this.parent.getParentSegments(segments.concat(this.parent))\n      : segments.reverse()\n  }\n\n  public setParent(parent: RouteNode) {\n    this.parent = parent\n    this.checkParents()\n  }\n\n  public setPath(path: string = '') {\n    this.path = path\n    this.parser = path ? new Path(path) : null\n  }\n\n  public add(\n    route: Route | Route[],\n    cb?: Callback,\n    sort: boolean = true\n  ): this {\n    if (route === undefined || route === null) {\n      return this\n    }\n\n    if (route instanceof Array) {\n      route.forEach(r => this.add(r, cb, sort))\n      return this\n    }\n\n    if (!(route instanceof RouteNode) && !(route instanceof Object)) {\n      throw new Error(\n        'RouteNode.add() expects routes to be an Object or an instance of RouteNode.'\n      )\n    } else if (route instanceof RouteNode) {\n      route.setParent(this)\n      this.addRouteNode(route, sort)\n    } else {\n      if (!route.name || !route.path) {\n        throw new Error(\n          'RouteNode.add() expects routes to have a name and a path defined.'\n        )\n      }\n\n      const routeNode = new RouteNode(route.name, route.path, route.children, {\n        finalSort: false,\n        onAdd: cb,\n        parent: this,\n        sort\n      })\n      const fullName = routeNode\n        .getParentSegments([routeNode])\n        .map(_ => _.name)\n        .join('.')\n      if (cb) {\n        cb({\n          ...route,\n          name: fullName\n        })\n      }\n      this.addRouteNode(routeNode, sort)\n    }\n\n    return this\n  }\n\n  public addNode(name: string, path: string) {\n    this.add(new RouteNode(name, path))\n    return this\n  }\n\n  public getPath(routeName: string): string | null {\n    const segmentsByName = this.getSegmentsByName(routeName)\n\n    return segmentsByName ? getPathFromSegments(segmentsByName) : null\n  }\n\n  public getNonAbsoluteChildren(): RouteNode[] {\n    return this.children.filter(child => !child.absolute)\n  }\n\n  public sortChildren() {\n    if (this.children.length) {\n      sortChildren(this.children)\n    }\n  }\n\n  public sortDescendants() {\n    this.sortChildren()\n    this.children.forEach(child => child.sortDescendants())\n  }\n\n  public buildPath(\n    routeName: string,\n    params: Record<string, any> = {},\n    options: BuildOptions = {}\n  ): string {\n    const segments = this.getSegmentsByName(routeName)\n\n    if (!segments) {\n      throw new Error(`[route-node][buildPath] '{routeName}' is not defined`)\n    }\n\n    return buildPathFromSegments(segments, params, options)\n  }\n\n  public buildState(\n    name: string,\n    params: Record<string, any> = {}\n  ): RouteNodeState | null {\n    const segments = this.getSegmentsByName(name)\n\n    if (!segments || !segments.length) {\n      return null\n    }\n\n    return {\n      name,\n      params,\n      meta: getMetaFromSegments(segments)\n    }\n  }\n\n  public matchPath(\n    path: string,\n    options: MatchOptions = {}\n  ): RouteNodeState | null {\n    if (path === '' && !options.strictTrailingSlash) {\n      path = '/'\n    }\n\n    const match = this.getSegmentsMatchingPath(path, options)\n\n    if (!match) {\n      return null\n    }\n\n    const matchedSegments = match.segments\n\n    if (matchedSegments[0].absolute) {\n      const firstSegmentParams = matchedSegments[0].getParentSegments()\n\n      matchedSegments.reverse()\n      matchedSegments.push(...firstSegmentParams)\n      matchedSegments.reverse()\n    }\n\n    const lastSegment = matchedSegments[matchedSegments.length - 1]\n    const lastSegmentSlashChild = lastSegment.findSlashChild()\n\n    if (lastSegmentSlashChild) {\n      matchedSegments.push(lastSegmentSlashChild)\n    }\n\n    return buildStateFromMatch(match)\n  }\n\n  private addRouteNode(route: RouteNode, sort: boolean = true): this {\n    const names = route.name.split('.')\n\n    if (names.length === 1) {\n      // Check duplicated routes\n      if (this.children.map(child => child.name).indexOf(route.name) !== -1) {\n        throw new Error(\n          `Alias \"${route.name}\" is already defined in route node`\n        )\n      }\n\n      // Check duplicated paths\n      if (this.children.map(child => child.path).indexOf(route.path) !== -1) {\n        throw new Error(`Path \"${route.path}\" is already defined in route node`)\n      }\n\n      this.children.push(route)\n\n      if (sort) {\n        this.sortChildren()\n      }\n    } else {\n      // Locate parent node\n      const segments = this.getSegmentsByName(names.slice(0, -1).join('.'))\n      if (segments) {\n        route.name = names[names.length - 1]\n        segments[segments.length - 1].add(route)\n      } else {\n        throw new Error(\n          `Could not add route named '${route.name}', parent is missing.`\n        )\n      }\n    }\n\n    return this\n  }\n\n  private checkParents() {\n    if (this.absolute && this.hasParentsParams()) {\n      throw new Error(\n        '[RouteNode] A RouteNode with an abolute path cannot have parents with route parameters'\n      )\n    }\n  }\n\n  private hasParentsParams(): boolean {\n    if (this.parent && this.parent.parser) {\n      const parser = this.parent.parser\n      const hasParams =\n        parser.hasUrlParams ||\n        parser.hasSpatParam ||\n        parser.hasMatrixParams ||\n        parser.hasQueryParams\n\n      return hasParams || this.parent.hasParentsParams()\n    }\n\n    return false\n  }\n\n  private findAbsoluteChildren(): RouteNode[] {\n    return this.children.reduce<RouteNode[]>(\n      (absoluteChildren, child) =>\n        absoluteChildren\n          .concat(child.absolute ? child : [])\n          .concat(child.findAbsoluteChildren()),\n      []\n    )\n  }\n\n  private findSlashChild(): RouteNode | undefined {\n    const slashChildren = this.getNonAbsoluteChildren().filter(\n      child => child.parser && /^\\/(\\?|$)/.test(child.parser.path)\n    )\n\n    return slashChildren[0]\n  }\n\n  private getSegmentsByName(routeName: string): RouteNode[] | null {\n    const findSegmentByName = (name: string, routes: RouteNode[]) => {\n      const filteredRoutes = routes.filter(r => r.name === name)\n      return filteredRoutes.length ? filteredRoutes[0] : undefined\n    }\n    const segments: RouteNode[] = []\n    let routes = this.parser ? [this] : this.children\n    const names = (this.parser ? [''] : []).concat(routeName.split('.'))\n\n    const matched = names.every(name => {\n      const segment = findSegmentByName(name, routes)\n      if (segment) {\n        routes = segment.children\n        segments.push(segment)\n        return true\n      }\n      return false\n    })\n\n    return matched ? segments : null\n  }\n\n  private getSegmentsMatchingPath(\n    path: string,\n    options: MatchOptions\n  ): MatchResponse | null {\n    const topLevelNodes = this.parser ? [this] : this.children\n    const startingNodes = topLevelNodes.reduce<RouteNode[]>(\n      (nodes, node) => nodes.concat(node, node.findAbsoluteChildren()),\n      []\n    )\n\n    const currentMatch = {\n      segments: [],\n      params: {}\n    }\n\n    const finalMatch = matchChildren(startingNodes, path, currentMatch, options)\n\n    if (\n      finalMatch &&\n      finalMatch.segments.length === 1 &&\n      finalMatch.segments[0].name === ''\n    ) {\n      return null\n    }\n\n    return finalMatch\n  }\n}\n"],"names":["getMetaFromSegments","segments","accName","reduce","meta","segment","urlParams","parser","params","p","allParams","queryParams","name","undefined","buildStateFromMatch","match","length","map","filter","join","buildPathFromSegments","options","_a","queryParamsMode","_b","trailingSlashMode","searchParams","nonSearchParams","segments_1","_i","push","spatParams","extraParams","Object","keys","acc","indexOf","concat","searchParamsObject","paramName","searchPart","build","path","segmentPath","ignoreSearch","urlParamsEncoding","absolute","replace","finalPath","test","slice","getPathFromSegments","getPath","split","getSearch","matchChildren","nodes","pathSegment","currentMatch","consumedBefore","strictTrailingSlash","_c","strongMatching","_d","caseSensitive","isRoot","child","remainingPath","children","partialTest","delimited","consumedPath","toLowerCase","querystring","forEach","param","remainingQueryParams_1","parse","getNonAbsoluteChildren","nodes_1","sortChildren","originalChildren","sort","sortPredicate","left","right","leftPath","rightPath","hasSpatParam","leftSegments","rightSegments","leftParamsCount","rightParamsCount","leftParamLength","rightParamLength","childRoutes","Path","parent","checkParents","add","onAdd","finalSort","sortDescendants","RouteNode","getParentSegments","reverse","route","cb","Array","r","_this","Error","setParent","addRouteNode","routeNode","fullName","_","routeName","segmentsByName","getSegmentsByName","getSegmentsMatchingPath","matchedSegments","firstSegmentParams","lastSegment","lastSegmentSlashChild","findSlashChild","names","hasParentsParams","hasParams","hasUrlParams","hasMatrixParams","hasQueryParams","absoluteChildren","findAbsoluteChildren","slashChildren","findSegmentByName","routes","filteredRoutes","matched","every","topLevelNodes","startingNodes","node","finalMatch"],"mappings":";;;;;;;;AASO,IAAMA,mBAAmB,GAAG,SAAtBA,mBAAsB,CACjCC,QADiC;MAG7BC,OAAO,GAAG,EAAd;SAEOD,QAAQ,CAACE,MAAT,CAAoC,UAACC,IAAD,EAAOC,OAAP;;;QACnCC,SAAS,eACbD,OAAO,CAACE,gDAAQD,UAAUH,OAA4B,UAACK,MAAD,EAASC,CAAT;MACpDD,MAAM,CAACC,CAAD,CAAN,GAAY,KAAZ;aACOD,MAAP;OACC,yCAAO,EAJG,CAAf;QAMME,SAAS,eACbL,OAAO,CAACE,gDAAQI,YAAYR,OAA4B,UAACK,MAAD,EAASC,CAAT;MACtDD,MAAM,CAACC,CAAD,CAAN,GAAY,OAAZ;aACOD,MAAP;OACCF,gDAAc,EAJJ,CAAf;;QAMID,OAAO,CAACO,IAAR,KAAiBC,SAArB,EAAgC;MAC9BX,OAAO,GAAGA,OAAO,GAAGA,OAAO,GAAG,GAAV,GAAgBG,OAAO,CAACO,IAA3B,GAAkCP,OAAO,CAACO,IAA3D;MACAR,IAAI,CAACF,OAAD,CAAJ,GAAgBQ,SAAhB;;;WAEKN,IAAP;GAjBK,EAkBJ,EAlBI,CAAP;CALK;AA0BP,AAAO,IAAMU,mBAAmB,GAAG,SAAtBA,mBAAsB,CACjCC,KADiC;MAG7B,CAACA,KAAD,IAAU,CAACA,KAAK,CAACd,QAAjB,IAA6B,CAACc,KAAK,CAACd,QAAN,CAAee,MAAjD,EAAyD;WAChD,IAAP;;;MAGIJ,IAAI,GAAGG,KAAK,CAACd,QAAN,CACVgB,GADU,CACN,UAAAZ,OAAA;WAAWA,OAAO,CAACO,IAAR;GADL,EAEVM,MAFU,CAEH,UAAAN,IAAA;WAAQA,IAAA;GAFL,EAGVO,IAHU,CAGL,GAHK,CAAb;MAIMX,MAAM,GAAGO,KAAK,CAACP,MAArB;SAEO;IACLI,IAAI,MADC;IAELJ,MAAM,QAFD;IAGLJ,IAAI,EAAEJ,mBAAmB,CAACe,KAAK,CAACd,QAAP;GAH3B;CAbK;AAoBP,AAAO,IAAMmB,qBAAqB,GAAG,SAAxBA,qBAAwB,CACnCnB,QADmC,EAEnCO,MAFmC,EAGnCa,OAHmC;uBAEnC,EAAA;IAAAb,WAAA;;;wBACA,EAAA;IAAAa,YAAA;;;MAEQC,4BAAA;MAAAC,gDAAA;MAA6BC,8BAA7B;MAA6BC,kDAA7B;MACFC,cAAY,GAAa,EAA/B;MACMC,eAAe,GAAa,EAAlC;;OAEsB,UAAA,EAAAC,qBAAtB,EAAsBC,sBAAtB,EAAsBA,IAAtB,EAAgC;QAArBxB,OAAO,iBAAb;QACKE,uBAAA;;QAEJA,MAAJ,EAAY;MACVmB,cAAY,CAACI,IAAb,MAAA,CAAAJ,cAAA,EAAqBnB,MAAM,CAACI,WAA5B;MACAgB,eAAe,CAACG,IAAhB,MAAA,CAAAH,eAAA,EAAwBpB,MAAM,CAACD,SAA/B;MACAqB,eAAe,CAACG,IAAhB,MAAA,CAAAH,eAAA,EAAwBpB,MAAM,CAACwB,UAA/B;;;;MAIAR,eAAe,KAAK,OAAxB,EAAiC;QACzBS,WAAW,GAAGC,MAAM,CAACC,IAAP,CAAY1B,MAAZ,EAAoBL,MAApB,CAClB,UAACgC,GAAD,EAAM1B,CAAN;aACEiB,cAAY,CAACU,OAAb,CAAqB3B,CAArB,MAA4B,CAAC,CAA7B,IAAkCkB,eAAe,CAACS,OAAhB,CAAwB3B,CAAxB,MAA+B,CAAC,CAAlE,GACI0B,GAAG,CAACE,MAAJ,CAAW5B,CAAX,CADJ,GAEI0B,GAFJ;KAFgB,EAKlB,EALkB,CAApB;IAOAT,cAAY,CAACI,IAAb,MAAA,CAAAJ,cAAA,EAAqBM,WAArB;;;MAGIM,kBAAkB,GAAGZ,cAAY,CAACvB,MAAb,CACzB,UAACgC,GAAD,EAAMI,SAAN;QACMN,MAAM,CAACC,IAAP,CAAY1B,MAAZ,EAAoB4B,OAApB,CAA4BG,SAA5B,MAA2C,CAAC,CAAhD,EAAmD;MACjDJ,GAAG,CAACI,SAAD,CAAH,GAAiB/B,MAAM,CAAC+B,SAAD,CAAvB;;;WAGKJ,GAAP;GANuB,EAQzB,EARyB,CAA3B;MAWMK,UAAU,GAAGC,kBAAK,CAACH,kBAAD,EAAqBjB,OAAO,CAACV,WAA7B,CAAxB;MAEM+B,IAAI,GAAGzC,QAAQ,CAClBE,MADU,CACK,UAACuC,IAAD,EAAOrC,OAAP;;;QACRsC,WAAW,eACftC,OAAO,CAACE,gDAAQkC,MAAMjC,QAAQ;MAC5BoC,YAAY,EAAE,IADc;MAE5BjC,WAAW,EAAEU,OAAO,CAACV,WAFO;MAG5BkC,iBAAiB,EAAExB,OAAO,CAACwB;4CACvB,EALS,CAAjB;WAOOxC,OAAO,CAACyC,QAAR,GAAmBH,WAAnB,GAAiCD,IAAI,GAAGC,WAA/C;GATS,EAUR,EAVQ;GAYVI,OAZU,CAYF,WAZE,EAYW,GAZX,CAAb;MAcIC,SAAS,GAAGN,IAAhB;;MAEIjB,iBAAiB,KAAK,QAA1B,EAAoC;IAClCuB,SAAS,GAAG,MAAMC,IAAN,CAAWP,IAAX,IAAmBA,IAAnB,GAA6BA,IAAI,MAA7C;GADF,MAEO,IAAIjB,iBAAiB,KAAK,OAAtB,IAAiCiB,IAAI,KAAK,GAA9C,EAAmD;IACxDM,SAAS,GAAG,MAAMC,IAAN,CAAWP,IAAX,IAAmBA,IAAI,CAACQ,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,CAAnB,GAAuCR,IAAnD;;;SAGKM,SAAS,IAAIR,UAAU,GAAG,MAAMA,UAAT,GAAsB,EAApC,CAAhB;CAjEK;AAoEP,AAAO,IAAMW,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAClD,QAAD;SACjCA,QAAQ,GAAGA,QAAQ,CAACgB,GAAT,CAAa,UAAAZ,OAAA;WAAWA,OAAO,CAACqC,IAAR;GAAxB,EAAsCvB,IAAtC,CAA2C,EAA3C,CAAH,GAAoD,IAA5D;CADK;;ACvHP,IAAMiC,OAAO,GAAG,SAAVA,OAAU,CAACV,IAAD;SAA0BA,IAAI,CAACW,KAAL,CAAW,GAAX,EAAgB,CAAhB,CAAA;CAA1C;;AAEA,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAACZ,IAAD;SAA0BA,IAAI,CAACW,KAAL,CAAW,GAAX,EAAgB,CAAhB,KAAsB,EAAtB;CAA5C;;AAEA,IAAME,aAAa,GAAG,SAAhBA,aAAgB,CACpBC,KADoB,EAEpBC,WAFoB,EAGpBC,YAHoB,EAIpBrC,OAJoB,EAKpBsC,cALoB;wBAIpB,EAAA;IAAAtC,YAAA;;;MAIEC,4BAAA;MAAAC,gDAAA;MACAC,gCADA;MACAoC,gDADA;MAEAC,2BAFA;MAEAC,0CAFA;MAGAC,0BAHA;MAGAC,0CAHA;MAKIC,MAAM,GAAGT,KAAK,CAACxC,MAAN,KAAiB,CAAjB,IAAsBwC,KAAK,CAAC,CAAD,CAAL,CAAS5C,IAAT,KAAkB,EAAvD;;iCAEWsD;;QAELnD,KAAK,GAAqB,IAA9B;QACIoD,aAAa,SAAjB;QACI9D,OAAO,GAAGoD,WAAd;;QAEIE,cAAc,KAAK,GAAnB,IAA0BO,KAAK,CAACxB,IAAN,KAAe,GAA7C,EAAkD;;;MAGhDrC,OAAO,GAAG,MAAMoD,WAAhB;;;QAGE,CAACS,KAAK,CAACE,QAAN,CAAepD,MAApB,EAA4B;MAC1BD,KAAK,GAAGmD,KAAK,CAAC3D,MAAN,CAAc0C,IAAd,CAAmB5C,OAAnB,EAA4B;QAClC2D,aAAa,eADqB;QAElCJ,mBAAmB,qBAFe;QAGlCjD,WAAW,EAAEU,OAAO,CAACV,WAHa;QAIlCkC,iBAAiB,EAAExB,OAAO,CAACwB;OAJrB,CAAR;;;QAQE,CAAC9B,KAAL,EAAY;MACVA,KAAK,GAAGmD,KAAK,CAAC3D,MAAN,CAAc8D,WAAd,CAA0BhE,OAA1B,EAAmC;QACzCiE,SAAS,EAAER,cAD8B;QAEzCE,aAAa,eAF4B;QAGzCrD,WAAW,EAAEU,OAAO,CAACV,WAHoB;QAIzCkC,iBAAiB,EAAExB,OAAO,CAACwB;OAJrB,CAAR;;;QAQE9B,KAAJ,EAAW;;UAELwD,YAAY,GAAGL,KAAK,CAAC3D,MAAN,CAAckC,KAAd,CAAoB1B,KAApB,EAA2B;QAC5C6B,YAAY,EAAE,IAD8B;QAE5CC,iBAAiB,EAAExB,OAAO,CAACwB;OAFV,CAAnB;;UAKI,CAACe,mBAAD,IAAwB,CAACM,KAAK,CAACE,QAAN,CAAepD,MAA5C,EAAoD;QAClDuD,YAAY,GAAGA,YAAY,CAACxB,OAAb,CAAqB,KAArB,EAA4B,EAA5B,CAAf;OARO;;;;UAaL1C,OAAO,CAACmE,WAAR,GAAsBpC,OAAtB,CAA8BmC,YAAY,CAACC,WAAb,EAA9B,MAA8D,CAAlE,EAAqE;QACnEL,aAAa,GAAG9D,OAAO,CAAC6C,KAAR,CAAcqB,YAAY,CAACvD,MAA3B,CAAhB;OADF,MAEO;QACLmD,aAAa,GAAG9D,OAAhB;;;UAGE,CAACuD,mBAAD,IAAwB,CAACM,KAAK,CAACE,QAAN,CAAepD,MAA5C,EAAoD;QAClDmD,aAAa,GAAGA,aAAa,CAACpB,OAAd,CAAsB,OAAtB,EAA+B,GAA/B,CAAhB;;;UAGM0B,wIAAA;MAKRN,aAAa,GACXf,OAAO,CAACe,aAAD,CAAP,IAA0BM,WAAW,GAAG,MAAIA,WAAP,GAAuB,EAA5D,CADF;;UAGE,CAACb,mBAAD,IACA,CAACK,MADD,IAEAE,aAAa,KAAK,GAFlB,IAGA,CAAC,MAAMlB,IAAN,CAAWsB,YAAX,CAJH,EAKE;QACAJ,aAAa,GAAG,EAAhB;;;MAGFT,YAAY,CAACzD,QAAb,CAAsB6B,IAAtB,CAA2BoC,KAA3B;MACAjC,MAAM,CAACC,IAAP,CAAYnB,KAAZ,EAAmB2D,OAAnB,CACE,UAAAC,KAAA;eAAUjB,YAAY,CAAClD,MAAb,CAAoBmE,KAApB,IAA6B5D,KAAM,CAAC4D,KAAD,CAApC;OADX;;UAII,CAACV,MAAD,IAAW,CAACE,aAAa,CAACnD,MAA9B,EAAsC;;iBAE7B0C;;;;UAGP,CAACO,MAAD,IACA1C,eAAe,KAAK,QADpB,IAEA4C,aAAa,CAAC/B,OAAd,CAAsB,GAAtB,MAA+B,CAHjC,EAIE;;YAEMwC,sBAAoB,GAAGC,kBAAK,CAChCV,aAAa,CAACjB,KAAd,CAAoB,CAApB,CADgC,EAEhC7B,OAAO,CAACV,WAFwB,CAAlC;QAKAsB,MAAM,CAACC,IAAP,CAAY0C,sBAAZ,EAAkCF,OAAlC,CACE,UAAA9D,IAAA;iBAAS8C,YAAY,CAAClD,MAAb,CAAoBI,IAApB,IAA4BgE,sBAAoB,CAAChE,IAAD,CAAjD;SADV;;iBAGO8C;;OA9DA;;;UAiEHU,QAAQ,GAAGF,KAAK,CAACY,sBAAN,EAAjB,CAjES;;UAmEL,CAACV,QAAQ,CAACpD,MAAd,EAAsB;;iBACb;;;;;eAGFuC,aAAa,CAClBa,QADkB,EAElBD,aAFkB,EAGlBT,YAHkB,EAIlBrC,OAJkB,EAKlBkD,YALkB;;;;;;OArGJ,UAAA,EAAAQ,eAApB,EAAoBlD,mBAApB,EAAoBA,IAApB;QAAWqC,KAAK,cAAX;;0BAAMA;;;;;SA+GJ,IAAP;CA9HF;;SCNwBc,aAAaZ;MAC7Ba,gBAAgB,GAAGb,QAAQ,CAAClB,KAAT,CAAe,CAAf,CAAzB;SAEOkB,QAAQ,CAACc,IAAT,CAAcC,aAAa,CAACF,gBAAD,CAA3B,CAAP;;;AAGF,IAAME,aAAa,GAAG,SAAhBA,aAAgB,CAACF,gBAAD;SAAmC,UACvDG,IADuD,EAEvDC,KAFuD;;;QAIjDC,QAAQ,GAAGF,IAAI,CAAC1C,IAAL,CACdK,OADc,CACN,QADM,EACI,EADJ,EAEdM,KAFc,CAER,GAFQ,EAEH,CAFG,EAGdN,OAHc,CAGN,SAHM,EAGK,IAHL,CAAjB;QAIMwC,SAAS,GAAGF,KAAK,CAAC3C,IAAN,CACfK,OADe,CACP,QADO,EACG,EADH,EAEfM,KAFe,CAET,GAFS,EAEJ,CAFI,EAGfN,OAHe,CAGP,SAHO,EAGI,IAHJ,CAAlB;;QAMIuC,QAAQ,KAAK,GAAjB,EAAsB;aACb,CAAP;;;QAEEC,SAAS,KAAK,GAAlB,EAAuB;aACd,CAAC,CAAR;;;;cAGEH,IAAI,CAAC7E,gDAAQiF,YAAjB,EAA+B;aACtB,CAAP;;;cAEEH,KAAK,CAAC9E,gDAAQiF,YAAlB,EAAgC;aACvB,CAAC,CAAR;;;;QAGIC,YAAY,GAAG,CAACH,QAAQ,CAACvE,KAAT,CAAe,KAAf,KAAyB,EAA1B,EAA8BC,MAAnD;QACM0E,aAAa,GAAG,CAACH,SAAS,CAACxE,KAAV,CAAgB,KAAhB,KAA0B,EAA3B,EAA+BC,MAArD;;QACIyE,YAAY,GAAGC,aAAnB,EAAkC;aACzB,CAAP;;;QAEED,YAAY,GAAGC,aAAnB,EAAkC;aACzB,CAAC,CAAR;;;;QAGIC,eAAe,eAAGP,IAAI,CAAC7E,gDAAQD,UAAUU,4CAAU,CAApC,CAArB;QACM4E,gBAAgB,eAAGP,KAAK,CAAC9E,gDAAQD,UAAUU,4CAAU,CAArC,CAAtB;;QACI2E,eAAe,GAAGC,gBAAtB,EAAwC;aAC/B,CAAC,CAAR;;;QAEED,eAAe,GAAGC,gBAAtB,EAAwC;aAC/B,CAAP;;;;QAGIC,eAAe,GAAG,CAACP,QAAQ,CAACjC,KAAT,CAAe,GAAf,EAAoBH,KAApB,CAA0B,CAAC,CAA3B,EAA8B,CAA9B,KAAoC,EAArC,EAAyClC,MAAjE;QACM8E,gBAAgB,GAAG,CAACP,SAAS,CAAClC,KAAV,CAAgB,GAAhB,EAAqBH,KAArB,CAA2B,CAAC,CAA5B,EAA+B,CAA/B,KAAqC,EAAtC,EAA0ClC,MAAnE;;QACI6E,eAAe,GAAGC,gBAAtB,EAAwC;aAC/B,CAAP;;;QAEED,eAAe,GAAGC,gBAAtB,EAAwC;aAC/B,CAAC,CAAR;;;;;WAIKb,gBAAgB,CAAC7C,OAAjB,CAAyBgD,IAAzB,IAAiCH,gBAAgB,CAAC7C,OAAjB,CAAyBiD,KAAzB,CAAxC;GAxDuD;CAAzD;;;;;;;oBCiEE,CACEzE,IADF,EAEE8B,IAFF,EAGEqD,WAHF,EAIE1E,OAJF;uBACE,EAAA;MAAAT,SAAA;;;uBACA,EAAA;MAAA8B,SAAA;;;8BACA,EAAA;MAAAqD,gBAAA;;;0BACA,EAAA;MAAA1E,YAAA;;;SAEKT,IAAL,GAAYA,IAAZ;SACKkC,QAAL,GAAgB,KAAKG,IAAL,CAAUP,IAAV,CAAhB;SACKA,IAAL,GAAY,KAAKI,QAAL,GAAgBJ,IAAI,CAACQ,KAAL,CAAW,CAAX,CAAhB,GAAgCR,IAA5C;SAEKnC,MAAL,GAAc,KAAKmC,IAAL,GAAY,IAAIsD,eAAJ,CAAS,KAAKtD,IAAd,CAAZ,GAAkC,IAAhD;SACK0B,QAAL,GAAgB,EAAhB;SACK6B,MAAL,GAAc5E,OAAO,CAAC4E,MAAtB;SAEKC,YAAL;SAEKC,GAAL,CACEJ,WADF,EAEE1E,OAAO,CAAC+E,KAFV,EAGE/E,OAAO,CAACgF,SAAR,GAAoB,KAApB,GAA4BhF,OAAO,CAAC6D,IAAR,KAAiB,KAH/C;;QAMI7D,OAAO,CAACgF,SAAZ,EAAuB;WAChBC,eAAL;;;WAGK,IAAP;;;EAGKC,mBAAA,kBAAA,GAAP,UAAyBtG,QAAzB;2BAAyB,EAAA;MAAAA,aAAA;;;WAChB,KAAKgG,MAAL,IAAe,KAAKA,MAAL,CAAY1F,MAA3B,GACH,KAAK0F,MAAL,CAAYO,iBAAZ,CAA8BvG,QAAQ,CAACoC,MAAT,CAAgB,KAAK4D,MAArB,CAA9B,CADG,GAEHhG,QAAQ,CAACwG,OAAT,EAFJ;GADK;;EAMAF,mBAAA,UAAA,GAAP,UAAiBN,MAAjB;SACOA,MAAL,GAAcA,MAAd;SACKC,YAAL;GAFK;;EAKAK,mBAAA,QAAA,GAAP,UAAe7D,IAAf;uBAAe,EAAA;MAAAA,SAAA;;;SACRA,IAAL,GAAYA,IAAZ;SACKnC,MAAL,GAAcmC,IAAI,GAAG,IAAIsD,eAAJ,CAAStD,IAAT,CAAH,GAAoB,IAAtC;GAFK;;EAKA6D,mBAAA,IAAA,GAAP,UACEG,KADF,EAEEC,EAFF,EAGEzB,IAHF;oBAAA;;uBAGE,EAAA;MAAAA,WAAA;;;QAEIwB,KAAK,KAAK7F,SAAV,IAAuB6F,KAAK,KAAK,IAArC,EAA2C;aAClC,IAAP;;;QAGEA,KAAK,YAAYE,KAArB,EAA4B;MAC1BF,KAAK,CAAChC,OAAN,CAAc,UAAAmC,CAAA;eAAKC,KAAI,CAACX,GAAL,CAASU,CAAT,EAAYF,EAAZ,EAAgBzB,IAAhB,CAAA;OAAnB;aACO,IAAP;;;QAGE,EAAEwB,KAAK,YAAYH,SAAnB,KAAiC,EAAEG,KAAK,YAAYzE,MAAnB,CAArC,EAAiE;YACzD,IAAI8E,KAAJ,CACJ,6EADI,CAAN;KADF,MAIO,IAAIL,KAAK,YAAYH,SAArB,EAAgC;MACrCG,KAAK,CAACM,SAAN,CAAgB,IAAhB;WACKC,YAAL,CAAkBP,KAAlB,EAAyBxB,IAAzB;KAFK,MAGA;UACD,CAACwB,KAAK,CAAC9F,IAAP,IAAe,CAAC8F,KAAK,CAAChE,IAA1B,EAAgC;cACxB,IAAIqE,KAAJ,CACJ,mEADI,CAAN;;;UAKIG,SAAS,GAAG,IAAIX,SAAJ,CAAcG,KAAK,CAAC9F,IAApB,EAA0B8F,KAAK,CAAChE,IAAhC,EAAsCgE,KAAK,CAACtC,QAA5C,EAAsD;QACtEiC,SAAS,EAAE,KAD2D;QAEtED,KAAK,EAAEO,EAF+D;QAGtEV,MAAM,EAAE,IAH8D;QAItEf,IAAI;OAJY,CAAlB;UAMMiC,QAAQ,GAAGD,SAAS,CACvBV,iBADc,CACI,CAACU,SAAD,CADJ,EAEdjG,GAFc,CAEV,UAAAmG,CAAA;eAAKA,CAAC,CAACxG,IAAF;OAFK,EAGdO,IAHc,CAGT,GAHS,CAAjB;;UAIIwF,EAAJ,EAAQ;QACNA,EAAE,mCACGD;UACH9F,IAAI,EAAEuG;UAFN,CAAF;;;WAKGF,YAAL,CAAkBC,SAAlB,EAA6BhC,IAA7B;;;WAGK,IAAP;GA/CK;;EAkDAqB,mBAAA,QAAA,GAAP,UAAe3F,IAAf,EAA6B8B,IAA7B;SACOyD,GAAL,CAAS,IAAII,SAAJ,CAAc3F,IAAd,EAAoB8B,IAApB,CAAT;WACO,IAAP;GAFK;;EAKA6D,mBAAA,QAAA,GAAP,UAAec,SAAf;QACQC,cAAc,GAAG,KAAKC,iBAAL,CAAuBF,SAAvB,CAAvB;WAEOC,cAAc,GAAGnE,mBAAmB,CAACmE,cAAD,CAAtB,GAAyC,IAA9D;GAHK;;EAMAf,mBAAA,uBAAA,GAAP;WACS,KAAKnC,QAAL,CAAclD,MAAd,CAAqB,UAAAgD,KAAA;aAAS,CAACA,KAAK,CAACpB,QAAP;KAA9B,CAAP;GADK;;EAIAyD,mBAAA,aAAA,GAAP;QACM,KAAKnC,QAAL,CAAcpD,MAAlB,EAA0B;MACxBgE,YAAY,CAAC,KAAKZ,QAAN,CAAZ;;GAFG;;EAMAmC,mBAAA,gBAAA,GAAP;SACOvB,YAAL;SACKZ,QAAL,CAAcM,OAAd,CAAsB,UAAAR,KAAA;aAASA,KAAK,CAACoC,eAAN,EAAA;KAA/B;GAFK;;EAKAC,mBAAA,UAAA,GAAP,UACEc,SADF,EAEE7G,MAFF,EAGEa,OAHF;yBAEE,EAAA;MAAAb,WAAA;;;0BACA,EAAA;MAAAa,YAAA;;;QAEMpB,QAAQ,GAAG,KAAKsH,iBAAL,CAAuBF,SAAvB,CAAjB;;QAEI,CAACpH,QAAL,EAAe;YACP,IAAI8G,KAAJ,CAAU,sDAAV,CAAN;;;WAGK3F,qBAAqB,CAACnB,QAAD,EAAWO,MAAX,EAAmBa,OAAnB,CAA5B;GAXK;;EAcAkF,mBAAA,WAAA,GAAP,UACE3F,IADF,EAEEJ,MAFF;yBAEE,EAAA;MAAAA,WAAA;;;QAEMP,QAAQ,GAAG,KAAKsH,iBAAL,CAAuB3G,IAAvB,CAAjB;;QAEI,CAACX,QAAD,IAAa,CAACA,QAAQ,CAACe,MAA3B,EAAmC;aAC1B,IAAP;;;WAGK;MACLJ,IAAI,MADC;MAELJ,MAAM,QAFD;MAGLJ,IAAI,EAAEJ,mBAAmB,CAACC,QAAD;KAH3B;GAVK;;EAiBAsG,mBAAA,UAAA,GAAP,UACE7D,IADF,EAEErB,OAFF;0BAEE,EAAA;MAAAA,YAAA;;;QAEIqB,IAAI,KAAK,EAAT,IAAe,CAACrB,OAAO,CAACuC,mBAA5B,EAAiD;MAC/ClB,IAAI,GAAG,GAAP;;;QAGI3B,KAAK,GAAG,KAAKyG,uBAAL,CAA6B9E,IAA7B,EAAmCrB,OAAnC,CAAd;;QAEI,CAACN,KAAL,EAAY;aACH,IAAP;;;QAGI0G,eAAe,GAAG1G,KAAK,CAACd,QAA9B;;QAEIwH,eAAe,CAAC,CAAD,CAAf,CAAmB3E,QAAvB,EAAiC;UACzB4E,kBAAkB,GAAGD,eAAe,CAAC,CAAD,CAAf,CAAmBjB,iBAAnB,EAA3B;MAEAiB,eAAe,CAAChB,OAAhB;MACAgB,eAAe,CAAC3F,IAAhB,MAAA,CAAA2F,eAAA,EAAwBC,kBAAxB;MACAD,eAAe,CAAChB,OAAhB;;;QAGIkB,WAAW,GAAGF,eAAe,CAACA,eAAe,CAACzG,MAAhB,GAAyB,CAA1B,CAAnC;QACM4G,qBAAqB,GAAGD,WAAW,CAACE,cAAZ,EAA9B;;QAEID,qBAAJ,EAA2B;MACzBH,eAAe,CAAC3F,IAAhB,CAAqB8F,qBAArB;;;WAGK9G,mBAAmB,CAACC,KAAD,CAA1B;GA/BK;;EAkCCwF,mBAAA,aAAA,GAAR,UAAqBG,KAArB,EAAuCxB,IAAvC;uBAAuC,EAAA;MAAAA,WAAA;;;QAC/B4C,KAAK,GAAGpB,KAAK,CAAC9F,IAAN,CAAWyC,KAAX,CAAiB,GAAjB,CAAd;;QAEIyE,KAAK,CAAC9G,MAAN,KAAiB,CAArB,EAAwB;;UAElB,KAAKoD,QAAL,CAAcnD,GAAd,CAAkB,UAAAiD,KAAA;eAASA,KAAK,CAACtD,IAAN;OAA3B,EAAuCwB,OAAvC,CAA+CsE,KAAK,CAAC9F,IAArD,MAA+D,CAAC,CAApE,EAAuE;cAC/D,IAAImG,KAAJ,CACJ,aAAUL,KAAK,CAAC9F,IAAhB,wCADI,CAAN;OAHoB;;;UASlB,KAAKwD,QAAL,CAAcnD,GAAd,CAAkB,UAAAiD,KAAA;eAASA,KAAK,CAACxB,IAAN;OAA3B,EAAuCN,OAAvC,CAA+CsE,KAAK,CAAChE,IAArD,MAA+D,CAAC,CAApE,EAAuE;cAC/D,IAAIqE,KAAJ,CAAU,YAASL,KAAK,CAAChE,IAAf,wCAAV,CAAN;;;WAGG0B,QAAL,CAActC,IAAd,CAAmB4E,KAAnB;;UAEIxB,IAAJ,EAAU;aACHF,YAAL;;KAhBJ,MAkBO;;UAEC/E,QAAQ,GAAG,KAAKsH,iBAAL,CAAuBO,KAAK,CAAC5E,KAAN,CAAY,CAAZ,EAAe,CAAC,CAAhB,EAAmB/B,IAAnB,CAAwB,GAAxB,CAAvB,CAAjB;;UACIlB,QAAJ,EAAc;QACZyG,KAAK,CAAC9F,IAAN,GAAakH,KAAK,CAACA,KAAK,CAAC9G,MAAN,GAAe,CAAhB,CAAlB;QACAf,QAAQ,CAACA,QAAQ,CAACe,MAAT,GAAkB,CAAnB,CAAR,CAA8BmF,GAA9B,CAAkCO,KAAlC;OAFF,MAGO;cACC,IAAIK,KAAJ,CACJ,gCAA8BL,KAAK,CAAC9F,IAApC,0BADI,CAAN;;;;WAMG,IAAP;GAlCM;;EAqCA2F,mBAAA,aAAA,GAAR;QACM,KAAKzD,QAAL,IAAiB,KAAKiF,gBAAL,EAArB,EAA8C;YACtC,IAAIhB,KAAJ,CACJ,wFADI,CAAN;;GAFI;;EAQAR,mBAAA,iBAAA,GAAR;QACM,KAAKN,MAAL,IAAe,KAAKA,MAAL,CAAY1F,MAA/B,EAAuC;UAC/BA,MAAM,GAAG,KAAK0F,MAAL,CAAY1F,MAA3B;UACMyH,SAAS,GACbzH,MAAM,CAAC0H,YAAP,IACA1H,MAAM,CAACiF,YADP,IAEAjF,MAAM,CAAC2H,eAFP,IAGA3H,MAAM,CAAC4H,cAJT;aAMOH,SAAS,IAAI,KAAK/B,MAAL,CAAY8B,gBAAZ,EAApB;;;WAGK,KAAP;GAZM;;EAeAxB,mBAAA,qBAAA,GAAR;WACS,KAAKnC,QAAL,CAAcjE,MAAd,CACL,UAACiI,gBAAD,EAAmBlE,KAAnB;aACEkE,gBAAgB,CACb/F,MADH,CACU6B,KAAK,CAACpB,QAAN,GAAiBoB,KAAjB,GAAyB,EADnC,EAEG7B,MAFH,CAEU6B,KAAK,CAACmE,oBAAN,EAFV,CAAA;KAFG,EAKL,EALK,CAAP;GADM;;EAUA9B,mBAAA,eAAA,GAAR;QACQ+B,aAAa,GAAG,KAAKxD,sBAAL,GAA8B5D,MAA9B,CACpB,UAAAgD,KAAA;aAASA,KAAK,CAAC3D,MAAN,IAAgB,YAAY0C,IAAZ,CAAiBiB,KAAK,CAAC3D,MAAN,CAAamC,IAA9B,CAAhB;KADW,CAAtB;WAIO4F,aAAa,CAAC,CAAD,CAApB;GALM;;EAQA/B,mBAAA,kBAAA,GAAR,UAA0Bc,SAA1B;QACQkB,iBAAiB,GAAG,SAApBA,iBAAoB,CAAC3H,IAAD,EAAe4H,MAAf;UAClBC,cAAc,GAAGD,MAAM,CAACtH,MAAP,CAAc,UAAA2F,CAAA;eAAKA,CAAC,CAACjG,IAAF,KAAWA,IAAX;OAAnB,CAAvB;aACO6H,cAAc,CAACzH,MAAf,GAAwByH,cAAc,CAAC,CAAD,CAAtC,GAA4C5H,SAAnD;KAFF;;QAIMZ,QAAQ,GAAgB,EAA9B;QACIuI,MAAM,GAAG,KAAKjI,MAAL,GAAc,CAAC,IAAD,CAAd,GAAuB,KAAK6D,QAAzC;QACM0D,KAAK,GAAG,CAAC,KAAKvH,MAAL,GAAc,CAAC,EAAD,CAAd,GAAqB,EAAtB,EAA0B8B,MAA1B,CAAiCgF,SAAS,CAAChE,KAAV,CAAgB,GAAhB,CAAjC,CAAd;QAEMqF,OAAO,GAAGZ,KAAK,CAACa,KAAN,CAAY,UAAA/H,IAAA;UACpBP,OAAO,GAAGkI,iBAAiB,CAAC3H,IAAD,EAAO4H,MAAP,CAAjC;;UACInI,OAAJ,EAAa;QACXmI,MAAM,GAAGnI,OAAO,CAAC+D,QAAjB;QACAnE,QAAQ,CAAC6B,IAAT,CAAczB,OAAd;eACO,IAAP;;;aAEK,KAAP;KAPc,CAAhB;WAUOqI,OAAO,GAAGzI,QAAH,GAAc,IAA5B;GAnBM;;EAsBAsG,mBAAA,wBAAA,GAAR,UACE7D,IADF,EAEErB,OAFF;QAIQuH,aAAa,GAAG,KAAKrI,MAAL,GAAc,CAAC,IAAD,CAAd,GAAuB,KAAK6D,QAAlD;QACMyE,aAAa,GAAGD,aAAa,CAACzI,MAAd,CACpB,UAACqD,KAAD,EAAQsF,IAAR;aAAiBtF,KAAK,CAACnB,MAAN,CAAayG,IAAb,EAAmBA,IAAI,CAACT,oBAAL,EAAnB,CAAA;KADG,EAEpB,EAFoB,CAAtB;QAKM3E,YAAY,GAAG;MACnBzD,QAAQ,EAAE,EADS;MAEnBO,MAAM,EAAE;KAFV;QAKMuI,UAAU,GAAGxF,aAAa,CAACsF,aAAD,EAAgBnG,IAAhB,EAAsBgB,YAAtB,EAAoCrC,OAApC,CAAhC;;QAGE0H,UAAU,IACVA,UAAU,CAAC9I,QAAX,CAAoBe,MAApB,KAA+B,CAD/B,IAEA+H,UAAU,CAAC9I,QAAX,CAAoB,CAApB,EAAuBW,IAAvB,KAAgC,EAHlC,EAIE;aACO,IAAP;;;WAGKmI,UAAP;GAzBM;;kBA2BV;GAjUA;;;;"}