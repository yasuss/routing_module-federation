{"version":3,"file":"route-node.cjs.production.min.js","sources":["../src/helpers.ts","../src/RouteNode.ts","../src/sortChildren.ts","../src/matchChildren.ts"],"sourcesContent":["import { build } from 'search-params'\nimport {\n  BuildOptions,\n  MatchResponse,\n  RouteNode,\n  RouteNodeState,\n  RouteNodeStateMeta\n} from './RouteNode'\n\nexport const getMetaFromSegments = (\n  segments: RouteNode[]\n): RouteNodeStateMeta => {\n  let accName = ''\n\n  return segments.reduce<RouteNodeStateMeta>((meta, segment) => {\n    const urlParams =\n      segment.parser?.urlParams.reduce<Record<string, any>>((params, p) => {\n        params[p] = 'url'\n        return params\n      }, {}) ?? {}\n\n    const allParams =\n      segment.parser?.queryParams.reduce<Record<string, any>>((params, p) => {\n        params[p] = 'query'\n        return params\n      }, urlParams) ?? {}\n\n    if (segment.name !== undefined) {\n      accName = accName ? accName + '.' + segment.name : segment.name\n      meta[accName] = allParams\n    }\n    return meta\n  }, {})\n}\n\nexport const buildStateFromMatch = (\n  match: MatchResponse\n): RouteNodeState | null => {\n  if (!match || !match.segments || !match.segments.length) {\n    return null\n  }\n\n  const name = match.segments\n    .map(segment => segment.name)\n    .filter(name => name)\n    .join('.')\n  const params = match.params\n\n  return {\n    name,\n    params,\n    meta: getMetaFromSegments(match.segments)\n  }\n}\n\nexport const buildPathFromSegments = (\n  segments: RouteNode[],\n  params: Record<string, any> = {},\n  options: BuildOptions = {}\n) => {\n  const { queryParamsMode = 'default', trailingSlashMode = 'default' } = options\n  const searchParams: string[] = []\n  const nonSearchParams: string[] = []\n\n  for (const segment of segments) {\n    const { parser } = segment\n\n    if (parser) {\n      searchParams.push(...parser.queryParams)\n      nonSearchParams.push(...parser.urlParams)\n      nonSearchParams.push(...parser.spatParams)\n    }\n  }\n\n  if (queryParamsMode === 'loose') {\n    const extraParams = Object.keys(params).reduce<string[]>(\n      (acc, p) =>\n        searchParams.indexOf(p) === -1 && nonSearchParams.indexOf(p) === -1\n          ? acc.concat(p)\n          : acc,\n      []\n    )\n    searchParams.push(...extraParams)\n  }\n\n  const searchParamsObject = searchParams.reduce<Record<string, any>>(\n    (acc, paramName) => {\n      if (Object.keys(params).indexOf(paramName) !== -1) {\n        acc[paramName] = params[paramName]\n      }\n\n      return acc\n    },\n    {}\n  )\n\n  const searchPart = build(searchParamsObject, options.queryParams)\n\n  const path = segments\n    .reduce<string>((path, segment) => {\n      const segmentPath =\n        segment.parser?.build(params, {\n          ignoreSearch: true,\n          queryParams: options.queryParams,\n          urlParamsEncoding: options.urlParamsEncoding\n        }) ?? ''\n\n      return segment.absolute ? segmentPath : path + segmentPath\n    }, '')\n    // remove repeated slashes\n    .replace(/\\/\\/{1,}/g, '/')\n\n  let finalPath = path\n\n  if (trailingSlashMode === 'always') {\n    finalPath = /\\/$/.test(path) ? path : `${path}/`\n  } else if (trailingSlashMode === 'never' && path !== '/') {\n    finalPath = /\\/$/.test(path) ? path.slice(0, -1) : path\n  }\n\n  return finalPath + (searchPart ? '?' + searchPart : '')\n}\n\nexport const getPathFromSegments = (segments: RouteNode[]): string | null =>\n  segments ? segments.map(segment => segment.path).join('') : null\n","import { Path, URLParamsEncodingType } from 'path-parser'\nimport { IOptions as QueryParamsOptions } from 'search-params'\n\nimport {\n  buildPathFromSegments,\n  buildStateFromMatch,\n  getMetaFromSegments,\n  getPathFromSegments\n} from './helpers'\nimport matchChildren from './matchChildren'\nimport sortChildren from './sortChildren'\n\nexport interface RouteDefinition {\n  name: string\n  path: string\n  [key: string]: any\n}\nexport type Route = RouteNode | RouteDefinition\nexport type Callback = (...args: any[]) => void\nexport type TrailingSlashMode = 'default' | 'never' | 'always'\nexport type QueryParamsMode = 'default' | 'strict' | 'loose'\n\nexport interface BuildOptions {\n  trailingSlashMode?: TrailingSlashMode\n  queryParamsMode?: QueryParamsMode\n  queryParams?: QueryParamsOptions\n  urlParamsEncoding?: URLParamsEncodingType\n}\n\nexport interface MatchOptions {\n  caseSensitive?: boolean\n  trailingSlashMode?: TrailingSlashMode\n  queryParamsMode?: QueryParamsMode\n  queryParams?: QueryParamsOptions\n  strictTrailingSlash?: boolean\n  strongMatching?: boolean\n  urlParamsEncoding?: URLParamsEncodingType\n}\n\nexport { QueryParamsOptions }\n\nexport interface MatchResponse {\n  segments: RouteNode[]\n  params: Record<string, any>\n}\n\nexport interface RouteNodeStateMeta {\n  [routeName: string]: {\n    [routeParams: string]: 'query' | 'url'\n  }\n}\n\nexport interface RouteNodeState {\n  name: string\n  params: Record<string, any>\n  meta: RouteNodeStateMeta\n}\n\nexport interface RouteNodeOptions {\n  finalSort?: boolean\n  onAdd?: Callback\n  parent?: RouteNode\n  sort?: boolean\n}\n\nexport class RouteNode {\n  public name: string\n  public absolute: boolean\n  public path: string\n  public parser: Path | null\n  public children: RouteNode[]\n  public parent?: RouteNode\n\n  constructor(\n    name: string = '',\n    path: string = '',\n    childRoutes: Route[] = [],\n    options: RouteNodeOptions = {}\n  ) {\n    this.name = name\n    this.absolute = /^~/.test(path)\n    this.path = this.absolute ? path.slice(1) : path\n\n    this.parser = this.path ? new Path(this.path) : null\n    this.children = []\n    this.parent = options.parent\n\n    this.checkParents()\n\n    this.add(\n      childRoutes,\n      options.onAdd,\n      options.finalSort ? false : options.sort !== false\n    )\n\n    if (options.finalSort) {\n      this.sortDescendants()\n    }\n\n    return this\n  }\n\n  public getParentSegments(segments: RouteNode[] = []): RouteNode[] {\n    return this.parent && this.parent.parser\n      ? this.parent.getParentSegments(segments.concat(this.parent))\n      : segments.reverse()\n  }\n\n  public setParent(parent: RouteNode) {\n    this.parent = parent\n    this.checkParents()\n  }\n\n  public setPath(path: string = '') {\n    this.path = path\n    this.parser = path ? new Path(path) : null\n  }\n\n  public add(\n    route: Route | Route[],\n    cb?: Callback,\n    sort: boolean = true\n  ): this {\n    if (route === undefined || route === null) {\n      return this\n    }\n\n    if (route instanceof Array) {\n      route.forEach(r => this.add(r, cb, sort))\n      return this\n    }\n\n    if (!(route instanceof RouteNode) && !(route instanceof Object)) {\n      throw new Error(\n        'RouteNode.add() expects routes to be an Object or an instance of RouteNode.'\n      )\n    } else if (route instanceof RouteNode) {\n      route.setParent(this)\n      this.addRouteNode(route, sort)\n    } else {\n      if (!route.name || !route.path) {\n        throw new Error(\n          'RouteNode.add() expects routes to have a name and a path defined.'\n        )\n      }\n\n      const routeNode = new RouteNode(route.name, route.path, route.children, {\n        finalSort: false,\n        onAdd: cb,\n        parent: this,\n        sort\n      })\n      const fullName = routeNode\n        .getParentSegments([routeNode])\n        .map(_ => _.name)\n        .join('.')\n      if (cb) {\n        cb({\n          ...route,\n          name: fullName\n        })\n      }\n      this.addRouteNode(routeNode, sort)\n    }\n\n    return this\n  }\n\n  public addNode(name: string, path: string) {\n    this.add(new RouteNode(name, path))\n    return this\n  }\n\n  public getPath(routeName: string): string | null {\n    const segmentsByName = this.getSegmentsByName(routeName)\n\n    return segmentsByName ? getPathFromSegments(segmentsByName) : null\n  }\n\n  public getNonAbsoluteChildren(): RouteNode[] {\n    return this.children.filter(child => !child.absolute)\n  }\n\n  public sortChildren() {\n    if (this.children.length) {\n      sortChildren(this.children)\n    }\n  }\n\n  public sortDescendants() {\n    this.sortChildren()\n    this.children.forEach(child => child.sortDescendants())\n  }\n\n  public buildPath(\n    routeName: string,\n    params: Record<string, any> = {},\n    options: BuildOptions = {}\n  ): string {\n    const segments = this.getSegmentsByName(routeName)\n\n    if (!segments) {\n      throw new Error(`[route-node][buildPath] '{routeName}' is not defined`)\n    }\n\n    return buildPathFromSegments(segments, params, options)\n  }\n\n  public buildState(\n    name: string,\n    params: Record<string, any> = {}\n  ): RouteNodeState | null {\n    const segments = this.getSegmentsByName(name)\n\n    if (!segments || !segments.length) {\n      return null\n    }\n\n    return {\n      name,\n      params,\n      meta: getMetaFromSegments(segments)\n    }\n  }\n\n  public matchPath(\n    path: string,\n    options: MatchOptions = {}\n  ): RouteNodeState | null {\n    if (path === '' && !options.strictTrailingSlash) {\n      path = '/'\n    }\n\n    const match = this.getSegmentsMatchingPath(path, options)\n\n    if (!match) {\n      return null\n    }\n\n    const matchedSegments = match.segments\n\n    if (matchedSegments[0].absolute) {\n      const firstSegmentParams = matchedSegments[0].getParentSegments()\n\n      matchedSegments.reverse()\n      matchedSegments.push(...firstSegmentParams)\n      matchedSegments.reverse()\n    }\n\n    const lastSegment = matchedSegments[matchedSegments.length - 1]\n    const lastSegmentSlashChild = lastSegment.findSlashChild()\n\n    if (lastSegmentSlashChild) {\n      matchedSegments.push(lastSegmentSlashChild)\n    }\n\n    return buildStateFromMatch(match)\n  }\n\n  private addRouteNode(route: RouteNode, sort: boolean = true): this {\n    const names = route.name.split('.')\n\n    if (names.length === 1) {\n      // Check duplicated routes\n      if (this.children.map(child => child.name).indexOf(route.name) !== -1) {\n        throw new Error(\n          `Alias \"${route.name}\" is already defined in route node`\n        )\n      }\n\n      // Check duplicated paths\n      if (this.children.map(child => child.path).indexOf(route.path) !== -1) {\n        throw new Error(`Path \"${route.path}\" is already defined in route node`)\n      }\n\n      this.children.push(route)\n\n      if (sort) {\n        this.sortChildren()\n      }\n    } else {\n      // Locate parent node\n      const segments = this.getSegmentsByName(names.slice(0, -1).join('.'))\n      if (segments) {\n        route.name = names[names.length - 1]\n        segments[segments.length - 1].add(route)\n      } else {\n        throw new Error(\n          `Could not add route named '${route.name}', parent is missing.`\n        )\n      }\n    }\n\n    return this\n  }\n\n  private checkParents() {\n    if (this.absolute && this.hasParentsParams()) {\n      throw new Error(\n        '[RouteNode] A RouteNode with an abolute path cannot have parents with route parameters'\n      )\n    }\n  }\n\n  private hasParentsParams(): boolean {\n    if (this.parent && this.parent.parser) {\n      const parser = this.parent.parser\n      const hasParams =\n        parser.hasUrlParams ||\n        parser.hasSpatParam ||\n        parser.hasMatrixParams ||\n        parser.hasQueryParams\n\n      return hasParams || this.parent.hasParentsParams()\n    }\n\n    return false\n  }\n\n  private findAbsoluteChildren(): RouteNode[] {\n    return this.children.reduce<RouteNode[]>(\n      (absoluteChildren, child) =>\n        absoluteChildren\n          .concat(child.absolute ? child : [])\n          .concat(child.findAbsoluteChildren()),\n      []\n    )\n  }\n\n  private findSlashChild(): RouteNode | undefined {\n    const slashChildren = this.getNonAbsoluteChildren().filter(\n      child => child.parser && /^\\/(\\?|$)/.test(child.parser.path)\n    )\n\n    return slashChildren[0]\n  }\n\n  private getSegmentsByName(routeName: string): RouteNode[] | null {\n    const findSegmentByName = (name: string, routes: RouteNode[]) => {\n      const filteredRoutes = routes.filter(r => r.name === name)\n      return filteredRoutes.length ? filteredRoutes[0] : undefined\n    }\n    const segments: RouteNode[] = []\n    let routes = this.parser ? [this] : this.children\n    const names = (this.parser ? [''] : []).concat(routeName.split('.'))\n\n    const matched = names.every(name => {\n      const segment = findSegmentByName(name, routes)\n      if (segment) {\n        routes = segment.children\n        segments.push(segment)\n        return true\n      }\n      return false\n    })\n\n    return matched ? segments : null\n  }\n\n  private getSegmentsMatchingPath(\n    path: string,\n    options: MatchOptions\n  ): MatchResponse | null {\n    const topLevelNodes = this.parser ? [this] : this.children\n    const startingNodes = topLevelNodes.reduce<RouteNode[]>(\n      (nodes, node) => nodes.concat(node, node.findAbsoluteChildren()),\n      []\n    )\n\n    const currentMatch = {\n      segments: [],\n      params: {}\n    }\n\n    const finalMatch = matchChildren(startingNodes, path, currentMatch, options)\n\n    if (\n      finalMatch &&\n      finalMatch.segments.length === 1 &&\n      finalMatch.segments[0].name === ''\n    ) {\n      return null\n    }\n\n    return finalMatch\n  }\n}\n","import { RouteNode } from './RouteNode'\n\nexport default function sortChildren(children: RouteNode[]) {\n  const originalChildren = children.slice(0)\n\n  return children.sort(sortPredicate(originalChildren))\n}\n\nconst sortPredicate = (originalChildren: RouteNode[]) => (\n  left: RouteNode,\n  right: RouteNode\n): number => {\n  const leftPath = left.path\n    .replace(/<.*?>/g, '')\n    .split('?')[0]\n    .replace(/(.+)\\/$/, '$1')\n  const rightPath = right.path\n    .replace(/<.*?>/g, '')\n    .split('?')[0]\n    .replace(/(.+)\\/$/, '$1')\n\n  // '/' last\n  if (leftPath === '/') {\n    return 1\n  }\n  if (rightPath === '/') {\n    return -1\n  }\n  // Spat params last\n  if (left.parser?.hasSpatParam) {\n    return 1\n  }\n  if (right.parser?.hasSpatParam) {\n    return -1\n  }\n  // No spat, number of segments (less segments last)\n  const leftSegments = (leftPath.match(/\\//g) || []).length\n  const rightSegments = (rightPath.match(/\\//g) || []).length\n  if (leftSegments < rightSegments) {\n    return 1\n  }\n  if (leftSegments > rightSegments) {\n    return -1\n  }\n  // Same number of segments, number of URL params ascending\n  const leftParamsCount = left.parser?.urlParams.length ?? 0\n  const rightParamsCount = right.parser?.urlParams.length ?? 0\n  if (leftParamsCount < rightParamsCount) {\n    return -1\n  }\n  if (leftParamsCount > rightParamsCount) {\n    return 1\n  }\n  // Same number of segments and params, last segment length descending\n  const leftParamLength = (leftPath.split('/').slice(-1)[0] || '').length\n  const rightParamLength = (rightPath.split('/').slice(-1)[0] || '').length\n  if (leftParamLength < rightParamLength) {\n    return 1\n  }\n  if (leftParamLength > rightParamLength) {\n    return -1\n  }\n  // Same last segment length, preserve definition order. Note that we\n  // cannot just return 0, as sort is not guaranteed to be a stable sort.\n  return originalChildren.indexOf(left) - originalChildren.indexOf(right)\n}\n","import { omit, parse } from 'search-params'\nimport { MatchOptions, MatchResponse, RouteNode } from './RouteNode'\nimport { TestMatch } from 'path-parser'\n\nconst getPath = (path: string): string => path.split('?')[0]\n\nconst getSearch = (path: string): string => path.split('?')[1] || ''\n\nconst matchChildren = (\n  nodes: RouteNode[],\n  pathSegment: string,\n  currentMatch: MatchResponse,\n  options: MatchOptions = {},\n  consumedBefore?: string\n): MatchResponse | null => {\n  const {\n    queryParamsMode = 'default',\n    strictTrailingSlash = false,\n    strongMatching = true,\n    caseSensitive = false\n  } = options\n  const isRoot = nodes.length === 1 && nodes[0].name === ''\n  // for (child of node.children) {\n  for (const child of nodes) {\n    // Partially match path\n    let match: TestMatch | null = null\n    let remainingPath\n    let segment = pathSegment\n\n    if (consumedBefore === '/' && child.path === '/') {\n      // when we encounter repeating slashes we add the slash\n      // back to the URL to make it de facto pathless\n      segment = '/' + pathSegment\n    }\n\n    if (!child.children.length) {\n      match = child.parser!.test(segment, {\n        caseSensitive,\n        strictTrailingSlash,\n        queryParams: options.queryParams,\n        urlParamsEncoding: options.urlParamsEncoding\n      })\n    }\n\n    if (!match) {\n      match = child.parser!.partialTest(segment, {\n        delimited: strongMatching,\n        caseSensitive,\n        queryParams: options.queryParams,\n        urlParamsEncoding: options.urlParamsEncoding\n      })\n    }\n\n    if (match) {\n      // Remove consumed segment from path\n      let consumedPath = child.parser!.build(match, {\n        ignoreSearch: true,\n        urlParamsEncoding: options.urlParamsEncoding\n      })\n\n      if (!strictTrailingSlash && !child.children.length) {\n        consumedPath = consumedPath.replace(/\\/$/, '')\n      }\n\n      // Can't create a regexp from the path because it might contain a\n      // regexp character.\n      if (segment.toLowerCase().indexOf(consumedPath.toLowerCase()) === 0) {\n        remainingPath = segment.slice(consumedPath.length)\n      } else {\n        remainingPath = segment\n      }\n\n      if (!strictTrailingSlash && !child.children.length) {\n        remainingPath = remainingPath.replace(/^\\/\\?/, '?')\n      }\n\n      const { querystring } = omit(\n        getSearch(segment.replace(consumedPath, '')),\n        child.parser!.queryParams,\n        options.queryParams\n      )\n      remainingPath =\n        getPath(remainingPath) + (querystring ? `?${querystring}` : '')\n      if (\n        !strictTrailingSlash &&\n        !isRoot &&\n        remainingPath === '/' &&\n        !/\\/$/.test(consumedPath)\n      ) {\n        remainingPath = ''\n      }\n\n      currentMatch.segments.push(child)\n      Object.keys(match).forEach(\n        param => (currentMatch.params[param] = match![param])\n      )\n\n      if (!isRoot && !remainingPath.length) {\n        // fully matched\n        return currentMatch\n      }\n      if (\n        !isRoot &&\n        queryParamsMode !== 'strict' &&\n        remainingPath.indexOf('?') === 0\n      ) {\n        // unmatched queryParams in non strict mode\n        const remainingQueryParams = parse(\n          remainingPath.slice(1),\n          options.queryParams\n        ) as any\n\n        Object.keys(remainingQueryParams).forEach(\n          name => (currentMatch.params[name] = remainingQueryParams[name])\n        )\n        return currentMatch\n      }\n      // Continue matching on non absolute children\n      const children = child.getNonAbsoluteChildren()\n      // If no children to match against but unmatched path left\n      if (!children.length) {\n        return null\n      }\n      // Else: remaining path and children\n      return matchChildren(\n        children,\n        remainingPath,\n        currentMatch,\n        options,\n        consumedPath\n      )\n    }\n  }\n\n  return null\n}\n\nexport default matchChildren\n"],"names":["getMetaFromSegments","segments","accName","reduce","meta","segment","urlParams","parser","params","p","allParams","queryParams","undefined","name","path","childRoutes","options","absolute","test","this","slice","Path","children","parent","checkParents","add","onAdd","finalSort","sort","sortDescendants","RouteNode","getParentSegments","concat","reverse","route","cb","Array","forEach","r","_this","Object","Error","setParent","addRouteNode","routeNode","fullName","map","_","join","routeName","segmentsByName","getSegmentsByName","filter","child","originalChildren","length","left","right","leftPath","replace","split","rightPath","hasSpatParam","leftSegments","match","rightSegments","leftParamsCount","rightParamsCount","leftParamLength","rightParamLength","indexOf","sortPredicate","sortChildren","_a","queryParamsMode","_b","trailingSlashMode","searchParams","nonSearchParams","segments_1","_i","push","spatParams","extraParams","keys","acc","searchParamsObject","paramName","searchPart","build","segmentPath","ignoreSearch","urlParamsEncoding","finalPath","buildPathFromSegments","strictTrailingSlash","getSegmentsMatchingPath","matchedSegments","firstSegmentParams","lastSegmentSlashChild","findSlashChild","buildStateFromMatch","names","hasParentsParams","hasUrlParams","hasMatrixParams","hasQueryParams","absoluteChildren","findAbsoluteChildren","getNonAbsoluteChildren","routes","every","filteredRoutes","findSegmentByName","finalMatch","matchChildren","nodes","pathSegment","currentMatch","consumedBefore","_c","strongMatching","_d","caseSensitive","isRoot","remainingPath","partialTest","delimited","consumedPath","toLowerCase","querystring","getPath","param","remainingQueryParams_1","parse","nodes_1","node"],"mappings":"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"}